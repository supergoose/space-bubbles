<!DOCTYPE html>
<!-- HTML5 Hello world by kirupa - http://www.kirupa.com/html5/getting_your_feet_wet_html5_pg1.htm -->
<html lang="en-us">

<head>
<meta charset="utf-8">
<title>Space Bubbles</title>

<script src="pixi.js"></script>
<script src="GameSprite.js"></script>

<script src="keyboard.js"></script>

<script src="Spaceship.js"></script>
<script src="Bullet.js"></script>
<script src="Asteroid.js"></script>
<script src="Explosion.js"></script>
<script src="ObjectPool.js"></script>

<style type="text/css">
canvas{
    margin:0 auto;
}
</style>


</head>

<body>

<script> 

/* Use Zero Sprites for sprite sheet packing http://zerosprites.com/detail/t25by/ */

/* global PIXI, keyboard, Spaceship, Bullet, Asteroid, ObjectPool, Collision, Utilities */
//https://github.com/kittykatattack/learningPixi#renderer

//Set PIXI aliases
var Container = PIXI.Container;
var Renderer = PIXI.autoDetectRenderer;
var Loader = PIXI.loader;
var Resources = PIXI.loader.resources;
var Sprite = PIXI.Sprite;
var Rectangle = PIXI.Rectangle;

//Create rendering equipment
var renderer = new Renderer(800,600);
var stage = new Container(0x000000);
var state = play;

var Mouse = renderer.plugins.interaction.mouse.global;

var time;

var w = keyboard(87);
var s = keyboard(83);
var a = keyboard(65);
var d = keyboard(68);
var space = keyboard(32);

document.body.appendChild(renderer.view);

renderer.render(stage);
renderer.view.style.position = "absolute";
renderer.view.style.display = "block";
renderer.autoResize = true;
renderer.resize(window.innerWidth-20, window.innerHeight-30);

//Start loading assets
Loader
.add("Ship", "img/spaceship.png")
.add("Bullet", "img/bullet.png")
.add("Asteroid-1", "img/asteroid-2.png")
.add("Explosion", "img/explosion-2.png")
.load(setup);

var player;
var playerBullets = null;
var explosions = null;
var asteroids = null;// new Asteroid();
//var bullet = null;

var t;
    
function setup()
{
    /*global Ticker */
    t = new PIXI.ticker.Ticker();
    
    player = new Spaceship(100, 100, Resources["Ship"].texture);
    
    playerBullets = new ObjectPool(Bullet, Resources["Bullet"].texture, 50);
    
    player.setBullets(playerBullets);
    
    player.setForward(w);
    player.setBrake(s);
    player.setFollow(Mouse);
    player.setTicker(t);
    
    // create an array of textures from an image path
    var explosionFrames = [];

    for (var i = 0; i < 10; i++) 
    {
        var rect = new Rectangle(i*32, 0, 32, 32);
        explosionFrames[i] = Resources["Explosion"].texture.clone();//.frame = rect;
        explosionFrames[i].frame = rect;
        
    }

    /* global Explosion */
    explosions = new ObjectPool(Explosion, explosionFrames, 20);
    stage.addChild(explosions);
    
    stage.addChild(player);
    
    asteroids = new ObjectPool(Asteroid, Resources["Asteroid-1"].texture, 50);
    stage.addChild(asteroids);

    stage.addChild(playerBullets);

    Mouse.down = false;
    document.addEventListener("mousedown", function(evt){
        Mouse.down = true;
    });
    
    document.addEventListener("mouseup", function(evt){
        Mouse.down = false;
    });
    
    gameloop();
}

function gameloop()
{
    requestAnimationFrame(gameloop);
    renderer.render(stage);
    
    state(t.elapsedMS);
}

function play(dt)
{
    checkCollisions();
}

function checkCollisions()
{
    var a = asteroids.getVisibleChildren();
    for(var j = 0; j < a.length; j++)
    {
        var asteroid = a[j];
        var visiBullets = playerBullets.getVisibleChildren();
        
        //Bullet collisions
        for(var i =0; i < visiBullets.length; i++)
    	{
    	    var bullet = visiBullets[i];
    	  
    	    if(Collision.circular(bullet, asteroid, 32))
    	    {
    	        //create explosion sprite
    	        var expl = explosions.getInvisibleChild();
    	        expl.x = asteroid.x;
    	        expl.y = asteroid.y;
    	        expl.visible = true;
    	        expl.gotoAndPlay(0);
    	        
    	        bullet.collided(asteroid);
    	        asteroid.collided(bullet);
    	    }
    	    
    	}
    	
    	//ship collision
    	if(Collision.circular(player, asteroid, 40))
    	{
    	    //get collision normal (as this is circular collision detection, we are using the position of both to ascertain the position of contact)
    	    var normal = Utils.normal(player, asteroid);
    	    
    	    //get relative velocity
    	    var relativeVelocity = Utils.subtractmatrices(asteroid.getVelocity(), player.getVelocity());
    	    
    	    //Find the velocity along the normal by multiplying the two matrices
    	    var velocityAlongNormal = Utils.dotproduct(relativeVelocity, normal);
    	    
    	    //Ignore if objects are moving away from each other
    	    if(velocityAlongNormal <= 0)
    	    {
    	        //Calculate the restitution (bounciness)
        	    //For now we will hardcode a restitution that all physics bodies will have
        	    //Usually, the restitution will be the lesser of the two objects restitution (min(a, b)
        	    var restitution = 0.1;
        	    
        	    //Calculate the impulse scalar 
        	    //The impulse scalar is the force that will push the two objects away from each other
        	    var impulseScalar = -(1+restitution)*velocityAlongNormal;
        	    
        	    //hardcode some mass for the sake of the tutorial
        	    var playerMass = 2;
        	    var asteroidMass = 10;
        	    
        	    //Work out the impulse scalar
        	    //The amount each object moves back should be based on their combined momentum (momentum = mass x velocity)
        	    impulseScalar /= (1/playerMass + 1/asteroidMass);
        	    
        	    //apply impulse
        	    var impulse = Utils.scalematrix(normal, impulseScalar);
        	    var playerImpulse = Utils.scalematrix(impulse, (1/playerMass));
        	    var asteroidImpulse = Utils.scalematrix(impulse, (1/asteroidMass));
        	    
        	    //Update velocity by subtracting from one and adding to the other
        	    var playerVel = player.getVelocity();
        	    var asteroidVel = asteroid.getVelocity();
        	    
        	    var pv =  Utils.subtractmatrices(playerVel, playerImpulse);
        	    var av = Utils.addmatrices(asteroidVel, asteroidImpulse);
        	    
        	    player.setVelocity(pv.x, pv.y);
        	    asteroid.setVelocity(av.x, av.y);
        	    
        	    
    	    }
    	    
    	}
    	
    	//asteroid collision
    	for(var i = 0; i < a.length; i++)
    	{
    	    if(i!=j)
    	    {
    	        var a2 = a[i];
    	        if(Collision.circular(a2, asteroid, 40))
            	{
            	    //get collision normal (as this is circular collision detection, we are using the position of both to ascertain the position of contact)
            	    var normal = Utils.normal(a2, asteroid);
            	    
            	    //get relative velocity
            	    var relativeVelocity = Utils.subtractmatrices(asteroid.getVelocity(), a2.getVelocity());
            	    
            	    //Find the velocity along the normal by multiplying the two matrices
            	    var velocityAlongNormal = Utils.dotproduct(relativeVelocity, normal);
            	    
            	    //Ignore if objects are moving away from each other
            	    if(velocityAlongNormal <= 0)
            	    {
            	        //Calculate the restitution (bounciness)
                	    //For now we will hardcode a restitution that all physics bodies will have
                	    //Usually, the restitution will be the lesser of the two objects restitution (min(a, b)
                	    var restitution = 0.1;
                	    
                	    //Calculate the impulse scalar 
                	    //The impulse scalar is the force that will push the two objects away from each other
                	    var impulseScalar = -(1+restitution)*velocityAlongNormal;
                	    
                	    //hardcode some mass for the sake of the tutorial
                	    var playerMass = 10;
                	    var asteroidMass = 10;
                	    
                	    //Work out the impulse scalar
                	    //The amount each object moves back should be based on their combined momentum (momentum = mass x velocity)
                	    impulseScalar /= (1/playerMass + 1/asteroidMass);
                	    
                	    //apply impulse
                	    var impulse = Utils.scalematrix(normal, impulseScalar);
                	    var playerImpulse = Utils.scalematrix(impulse, (1/playerMass));
                	    var asteroidImpulse = Utils.scalematrix(impulse, (1/asteroidMass));
                	    
                	    //Update velocity by subtracting from one and adding to the other
                	    var playerVel = a2.getVelocity();
                	    var asteroidVel = asteroid.getVelocity();
                	    
                	    var pv =  Utils.subtractmatrices(playerVel, playerImpulse);
                	    var av = Utils.addmatrices(asteroidVel, asteroidImpulse);
                	    
                	    a2.setVelocity(pv.x, pv.y);
                	    asteroid.setVelocity(av.x, av.y);
                	    
                	    
            	    }
            	    
            	}
    	    }
    	}
    	
    	
    	
    	// Calculate relative velocity in terms of the normal direction
    	
    }

}


var Collision = {
    circular: function(a,b,r)
    {
        var difx = a.x-b.x;
        var dify = a.y-b.y;
    	return (difx*difx+dify*dify < r*r); //optimised http://gamedevelopment.tutsplus.com/tutorials/how-to-create-a-custom-2d-physics-engine-the-basics-and-impulse-resolution--gamedev-6331
    	
    }
}

var Utils = {
    hypot: function(a, b)
    {
        return Math.sqrt((a*a)+(b*b));
    },
    dotproduct: function(a, b)
    {
        return (a.x*b.x)+(a.y*b.y);
    },
    subtractmatrices: function(a, b)
    {
        var v = {x:0, y:0};
        v.x = a.x - b.x;
        v.y = a.y - b.y;
        return v;
    },
    addmatrices: function(a,b)
    {
        var v = {x:0, y:0};
        v.x = a.x + b.x;
        v.y = a.y + b.y;
        return v;
    },
    normal: function(a, b)
    {
        //Calculate collision normal
	    var dx = a.x - b.x;
	    var dy = a.y - b.y;
	    
	    //one normal is -dx, dy the other is dx, -dy
	    var normal = {x:dx, y:dy};
	    
	    //normalise it
	    var b = Math.max(Math.abs(dx), Math.abs(dy));
	    normal = Utils.scalematrix(normal, 1/b);
	    return normal;
    },
    scalematrix: function(m, s)
    {
        var v = {x:0, y:0};
        v.x = m.x*s;
        v.y = m.y*s;
        return v;
    }
}

</script>

</body>
</html>
